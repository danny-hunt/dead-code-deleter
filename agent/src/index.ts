#!/usr/bin/env node

import { spawn } from "child_process";
import { promisify } from "util";
import { exec as execCallback } from "child_process";
import path from "path";

const exec = promisify(execCallback);

// Configuration
const PLATFORM_URL = process.env.PLATFORM_URL || "https://dead-code-deleter.vercel.app";
const PROJECT_ID = process.env.PROJECT_ID || "exampleapp";
const POLL_INTERVAL = parseInt(process.env.POLL_INTERVAL || "5000", 10);
const EXAMPLEAPP_PATH = process.env.EXAMPLEAPP_PATH || path.resolve(__dirname, "../../exampleapp");
const WORKSPACE_ROOT = process.env.WORKSPACE_ROOT || path.resolve(__dirname, "../..");

interface DeletionQueueItem {
  projectId: string;
  file: string;
  name: string;
  line: number;
  queuedAt: number;
}

interface DeletionsResponse {
  deletions: DeletionQueueItem[];
}

/**
 * Fetch deletions from the platform
 */
async function fetchDeletions(): Promise<DeletionQueueItem[]> {
  try {
    const url = `${PLATFORM_URL}/api/deletions?projectId=${PROJECT_ID}`;
    console.log(`[${new Date().toISOString()}] Polling ${url}`);

    const response = await fetch(url);

    if (!response.ok) {
      console.error(`Failed to fetch deletions: ${response.status} ${response.statusText}`);
      return [];
    }

    const data = (await response.json()) as DeletionsResponse;
    return data.deletions || [];
  } catch (error) {
    console.error("Error fetching deletions:", error);
    return [];
  }
}

/**
 * Generate a prompt for cursor-agent to delete functions
 */
function generateDeletionPrompt(deletions: DeletionQueueItem[]): string {
  const functionList = deletions.map((d) => `  - ${d.name} in ${d.file} (line ${d.line})`).join("\n");

  return `Please remove the following dead code functions from the exampleapp/ directory and any orphaned functionality that becomes unused as a result:

${functionList}

Instructions:
1. Delete each of the listed functions
2. Remove any imports, types, or helper functions that are only used by these deleted functions
3. Clean up any unused variables or constants
4. Remove any routes or API endpoints that only exist to call these functions
5. Update any documentation that references these functions
6. Ensure the code still compiles and all remaining functionality works correctly

After making the changes, verify that the application still builds successfully.`;
}

/**
 * Execute cursor-agent to perform deletions
 */
async function executeCursorAgent(prompt: string): Promise<string> {
  console.log("\n" + "=".repeat(80));
  console.log("CURSOR AGENT PROMPT:");
  console.log("=".repeat(80));
  console.log(prompt);
  console.log("=".repeat(80) + "\n");

  return new Promise((resolve, reject) => {
    console.log(`Executing cursor-agent in workspace: ${WORKSPACE_ROOT}`);

    const cursorAgent = spawn("cursor-agent", ["--print", prompt], {
      cwd: WORKSPACE_ROOT,
      stdio: "pipe",
      shell: true,
    });

    let stdout = "";
    let stderr = "";

    cursorAgent.stdout.on("data", (data) => {
      const output = data.toString();
      stdout += output;
      process.stdout.write(output);
    });

    cursorAgent.stderr.on("data", (data) => {
      const output = data.toString();
      stderr += output;
      process.stderr.write(output);
    });

    cursorAgent.on("close", (code) => {
      if (code === 0) {
        console.log(`\n[${new Date().toISOString()}] cursor-agent completed successfully`);
        resolve(stdout);
      } else {
        console.error(`\n[${new Date().toISOString()}] cursor-agent exited with code ${code}`);
        reject(new Error(`cursor-agent failed with code ${code}\n${stderr}`));
      }
    });

    cursorAgent.on("error", (error) => {
      console.error(`\n[${new Date().toISOString()}] Failed to start cursor-agent:`, error);
      reject(error);
    });
  });
}

/**
 * Create a Git branch for the changes
 */
async function createBranch(branchName: string): Promise<void> {
  console.log(`Creating branch: ${branchName}`);
  await exec(`git checkout -b ${branchName}`, { cwd: WORKSPACE_ROOT });
}

/**
 * Commit changes
 */
async function commitChanges(deletions: DeletionQueueItem[]): Promise<void> {
  console.log("Staging changes...");
  await exec("git add .", { cwd: WORKSPACE_ROOT });

  const functionNames = deletions.map((d) => d.name).join(", ");
  const commitMessage = `chore: remove dead code functions

Removed ${deletions.length} unused function(s):
${deletions.map((d) => `- ${d.name} (${d.file}:${d.line})`).join("\n")}

This change was automatically generated by the dead-code-deleter agent.`;

  console.log("Committing changes...");
  await exec(`git commit -m "${commitMessage.replace(/"/g, '\\"')}"`, {
    cwd: WORKSPACE_ROOT,
  });
}

/**
 * Create a Pull Request using GitHub CLI
 */
async function createPullRequest(branchName: string, deletions: DeletionQueueItem[]): Promise<void> {
  console.log("Pushing branch to remote...");
  await exec(`git push origin ${branchName}`, { cwd: WORKSPACE_ROOT });

  const functionNames = deletions.map((d) => d.name).join(", ");
  const title = `Remove dead code: ${functionNames}`;
  const body = `## Dead Code Removal

This PR removes ${deletions.length} unused function(s) identified by the dead-code-deleter platform:

${deletions.map((d) => `- \`${d.name}\` in \`${d.file}\` (line ${d.line})`).join("\n")}

### Changes Made
- Removed the listed functions
- Cleaned up any orphaned imports, types, and helper functions
- Removed unused routes and API endpoints
- Updated documentation as needed

### Verification
The code has been verified to compile successfully after the changes.

---
*This PR was automatically created by the dead-code-deleter agent.*`;

  console.log("Creating pull request...");
  const { stdout } = await exec(
    `gh pr create --title "${title.replace(/"/g, '\\"')}" --body "${body.replace(/"/g, '\\"')}"`,
    { cwd: WORKSPACE_ROOT }
  );

  console.log("Pull request created:");
  console.log(stdout);
}

/**
 * Process deletions by calling cursor-agent and creating a PR
 */
async function processDeletions(deletions: DeletionQueueItem[]): Promise<void> {
  console.log(`\n[${new Date().toISOString()}] Processing ${deletions.length} deletion(s)...`);

  try {
    // Generate timestamp for unique branch name
    const timestamp = Date.now();
    const branchName = `dead-code-removal-${timestamp}`;

    // Create a new branch
    await createBranch(branchName);

    // Generate the deletion prompt
    const prompt = generateDeletionPrompt(deletions);

    // Execute cursor-agent to perform the deletions
    await executeCursorAgent(prompt);

    // Commit the changes
    await commitChanges(deletions);

    // Create a pull request
    await createPullRequest(branchName, deletions);

    console.log(`\n[${new Date().toISOString()}] Successfully processed deletions and created PR`);
  } catch (error) {
    console.error(`\n[${new Date().toISOString()}] Error processing deletions:`, error);

    // Try to return to main branch on error
    try {
      await exec("git checkout main", { cwd: WORKSPACE_ROOT });
    } catch (checkoutError) {
      console.error("Failed to return to main branch:", checkoutError);
    }

    throw error;
  }
}

/**
 * Main polling loop
 */
async function pollForDeletions(): Promise<void> {
  console.log(`[${new Date().toISOString()}] Dead Code Deleter Agent started`);
  console.log(`Platform URL: ${PLATFORM_URL}`);
  console.log(`Project ID: ${PROJECT_ID}`);
  console.log(`Poll Interval: ${POLL_INTERVAL}ms`);
  console.log(`Exampleapp Path: ${EXAMPLEAPP_PATH}`);
  console.log(`Workspace Root: ${WORKSPACE_ROOT}`);
  console.log("");

  while (true) {
    try {
      const deletions = await fetchDeletions();

      if (deletions.length > 0) {
        console.log(`Found ${deletions.length} function(s) to delete`);
        await processDeletions(deletions);
      } else {
        console.log(`[${new Date().toISOString()}] No deletions found, continuing to poll...`);
      }
    } catch (error) {
      console.error(`[${new Date().toISOString()}] Error in polling loop:`, error);
    }

    // Wait before next poll
    await new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL));
  }
}

// Start the agent
pollForDeletions().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
